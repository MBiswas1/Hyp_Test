{
    "collab_server" : "",
    "contents" : "library(mvtnorm)\nlibrary(mgcv)\nlibrary(nnlasso)\nlibrary(kernlab)\nlibrary(clusterGeneration)\nlibrary(glmnet)\nlibrary(refund)\nlibrary(fpca)\n\n# Getting the intervals\ndis.uni <- function(n)\n{\n  m.i <- ceiling(runif(n,6,14))\n  return(m.i)\n}\n\n# generate t\nt.gen <- function(m)\n{\n  return(seq(0,1,len = m))\n}\n\n# generate mu\nmu.gen <- function(t)\n{\n  return(t)\n}\n\n# Generate error\nerr.gen<- function(n, m, t)\n{\n  zi <- rmvnorm(n,,diag(c(1, 2)))\n  wn <- matrix(rnorm(n*m), n)\n  fn <- sqrt(2) * rbind(cos(2 * pi * t), sin(2 * pi * t))\n  e <- zi %*% fn + wn\n  return(t(e))\n}\n\n# Generate X1\nx1.gen<- function(n,q)\n{\n  return(t(rmvnorm(n,,diag(q))))\n}\n\ndata.gen <- function(n, m, t, q, seed = 1000, prob)\n{\n  set.seed(seed)\n  X <- x1.gen(n,q)\n  Z <- gen.cov(n, prob)\n  Y.star <- t(gen.eta(t)) %*% Z + err.gen(n, m, t)\n  m.i <- dis.uni(n)\n  Y.star2 <- NULL\n  index <- NULL\n  t.star <- NULL\n  for(i in 1:n)\n  {\n    index[[i]] <- sort(sample(seq(1:m), m.i[i]), decreasing = F)\n    Y.star2[[i]] <- Y.star[index[[i]],i]\n    t.star[[i]] <- t[index[[i]]]\n  }\n  return(list(X = X, Y = Y.star2, Z = Z, t.star=t.star, index = index, m.i = m.i))\n}\n\nker.X <- function(X,t, c)\n{\n  K <- c*(t(X)%*%X)\n  return(K)\n}\n\n# ker.X2 <- function(X,t, m,)\n# {\n#   t <- as.matrix(t)\n#   c <- sum(outer(seq(1:m), seq(1:m), function(i,j) exp(-abs(t[i]-t[j]))))\n#   K <- c*t(X)%*%X\n#   return(K)\n# }\n\nkern.miss <- function(t,seq)\n{\n  n <- length(t)\n  C0 <- matrix(0, n, n)\n  for( i in 1:n )\n  {\n    C0[i, ] <- sapply(seq, function(j) sum(exp(-abs(Filter(Negate(is.null), intersect(unlist(t[i]), unlist(t[j])))))))\n    #mapply(function(i,j) intersect(unlist(t[i]), unlist(t[j])), t, t)\n  }\n  return(C0)\n}\n\nest.sig <- function(Y, m, t, index)\n{\n  # dat <- data.frame(.id = c(unlist(index)), .index = c(unlist(t.star)))\n  # dat$.value <- as.vector(unlist(Y.center))\n  # dat2 <- dat[with(dat, order(.id)),]\n  dat <- cbind(unlist(index), unlist(Y), unlist(t))\n  f <- fpca.mle(data.m = dat, M.set =5, r.set = 5)\n  eval <- f$eigenvalues\n  evec <- f$eigenfunctions[,c(1,seq(1:50)*10+1)]\n  f2 <- f$error_var\n  if(length(eval) == 1)\n  {  sig <- eval * t(evec) %*% evec + f2*diag(m)\n  }else\n    sig <- t(evec)%*%diag(eval)%*%evec + f2*diag(m)\n  return(list(sig = sig, eval = eval, evec = evec, f2 = f2))\n}\n\n\ntest.stat <- function(X, Y, t, index, m, c)\n{\n  K <- ker.X(X, t, c)\n  n <- nrow(K)\n  Y.0 <- matrix(0,m,n)\n  for(i in 1:n)\n  Y.0[index[[i]],i] <- Y[[i]]\n  T <- sum(Y.0 %*% K %*% t(Y.0))\n  return(T)\n}\n\ndistn <- function(X, t, m, m.i, n, index, sigma, c, fit.val, T, Z1, Z2)\n{\n  # y <- multi(n, m, eval, evec, f2)\n  y <- mvrnorm(n, rep(0, m), sigma)\n  K <- ker.X(X, t, c)\n  Y.star <- NULL\n  for(i in 1:n)\n    Y.star[[i]] <- t(y)[index[[i]],i]\n  Y.star2 <- unlist(Y.star) + fit.val\n  fit <- gam(Y.star2~s(T) + s(T, by = Z1) + s(T, by = Z2))\n  Y.center <- Y.star2 - fit$fitted.values\n  Y.center <- tolist(Y.center, m.i, n)\n  Y.0 <- matrix(0,m,n)\n  for(i in 1:n)\n    Y.0[index[[i]],i] <- Y.center[[i]]\n  T0 <- sum(Y.0 %*% K %*% t(Y.0))\n  return(T0)\n\n}\n\ngen.cov <- function(n, prob)\n{\n  z0 <- rep(1, n)\n  z1 <- rnorm(n)\n  z2 <- rbinom(n, 1, prob)\n  return(rbind(z0, z1, z2))\n}\n\ngen.eta <- function(t)\n{\n  mu <- mu.gen(t)\n  eta1 <- sin(2*pi*t)\n  eta2 <- cos(2*pi*t)\n  return(rbind(mu, eta1, eta2))\n}\n\ntolist <- function(Y, m.i, n)\n{\n  c <- 1\n  Y.l <- NULL\n  for(i in 1:n)\n  {\n    Y.l[[i]] <- Y[c : (c + m.i[i] - 1)]\n    c <- c + m.i[i]\n  }\n  return(Y.l)\n}\n\n## Body of code starts here\n\ns <- 2017\nn <- 100\nrep <- 1000\nm <- 51\nq <- 5\nt <- t.gen(m)\nsim <- 1000\nT <- rep(NA, sim)\np.val <- rep(NA, rep)\nprob <- 0.4\nseq <- seq(1:n)\n\nfor( r in 1:rep)\n{\n  # try({\n  # Generate data\n  data <- data.gen(n, m, t, q, seed = s, prob)\n  index <- data$index\n  m.i <- data$m.i\n  X <- data$X\n  Y <- data$Y\n  Z <- data$Z\n  Z1 <- sapply(seq,function(i) rep(Z[2,i], m.i[i]))\n  Z2 <- sapply(seq,function(i) rep(Z[3,i], m.i[i]))\n  Z1 <- c(unlist(Z1))\n  Z2 <- c(unlist(Z2))\n  t.star <- data$t.star\n  Y0 <- c(unlist(Y))\n  T <- c(unlist(t.star))\n\n  fit <- gam(Y0~s(T) + s(T, by = Z1) + s(T, by = Z2))\n  Y.center <- Y0 - fit$fitted.values\n  Y.center <- tolist(Y.center, m.i, n)\n\n  est.sigma <- est.sig(Y.center, m, t.star, index)\n  sig <- est.sigma$sig\n\n  C <- kern.miss(t.star, seq)\n\n  # Getting test statistics\n  T0 <- test.stat(X, Y.center, t.star, index, m, C)\n\n  #Simulating null distribution\n  T1 <- replicate(sim, distn(X, t.star, m, m.i, n, index, sig, C, fit$fitted.values, T, Z1, Z2))\n\n  #p-value\n  p.val[r] <- sum(T1>T0)/sim\n\n  # })\n\n  # Ready for next simulation\n  s <- s + 1\n\n}\n\nhist(p.val, nclass = 20)\nmean(p.val<0.05,na.rm=TRUE)\n",
    "created" : 1510123247931.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1337103863",
    "id" : "2C4E7257",
    "lastKnownWriteTime" : 1510123330,
    "last_content_update" : 1510123330168,
    "path" : "C:/partition1/NCSU/Research/Dr. Maity/score_missing.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}