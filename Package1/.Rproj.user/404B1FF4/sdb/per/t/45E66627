{
    "collab_server" : "",
    "contents" : "library(mvtnorm)\nlibrary(gam)\nlibrary(nnlasso)\nlibrary(kernlab)\nlibrary(clusterGeneration)\nlibrary(glmnet)\nlibrary(fpca)\n\n# Getting the intervals\ndis.uni <- function(n)\n{\n  m.i <- ceiling(runif(n,6,13))\n  return(m.i)\n}\n\n# generate t\nt.gen <- function(m)\n{\n    return(seq(0,1,len=m+1)[-1])\n}\n\n# generate beta1\nbeta1.gen <- function(x,t)\n{\n  y <- (rowSums(x))^2\n  beta <- exp(-(t%*%t(y)))\n  return(beta*15-20)\n}\n\n# Generate beta2\nbeta2.gen <- function(x,t)\n{\n  return(kronecker(cos(2*pi*t),t((rowSums(x))^2)))\n}\n\nbeta3.gen <- function(x,t)\n{\n  return(matrix(0,m,n))\n}\n\nbeta4.gen <- function(x,t)\n{\n  return(matrix(0,m,n))\n}\n\nbeta5.gen <- function(x,t)\n{\n  return(matrix(0,m,n))\n}\n\n# Generate error\nerr.gen<- function(n,m,sigma=1)\n{\n  ar.sim <- matrix(NA,m,n)\n  for( i in 1:m)\n  ar.sim[i,]<-arima.sim(model=list(ar=sigma),n)\n  return(ar.sim)\n}\n\n# Generate general effect\nmu.gen<- function(t,n)\n{\n  return(kronecker(t,t(rep(1,n))))\n}\n\n# Generate X1\nx1.gen<- function(n,q)\n{\n  return(rmvnorm(n,,diag(q)))\n}\n\n# Generate X2\nx2.gen<- function(n,q, sigma = 0.2)\n{\n  ar.sim <- matrix(NA,n,q)\n  for( i in 1:q)\n    ar.sim[,i]<-arima.sim(model=list(ar=sigma),n)\n  return(ar.sim)\n}\n\n# Generate X3\nx3.gen<- function(n,q)\n{\n  return(rmvnorm(n,,diag(seq(1,q))))\n}\n\n# Generate X4\nx4.gen<- function(n, q)\n{\n  return(rmvnorm(n,,2*diag(q)))\n}\n\n# Generate X5\nx5.gen<- function(n, q)\n{\n  return(rmvnorm(n,,diag(seq(1,q)+1)))\n}\n\n# Generate X6\nx6.gen<- function(n, q, sigma=0.4)\n{\n  ar.sim <- matrix(NA,n,q)\n  for( i in 1:q)\n    ar.sim[,i]<-arima.sim(model=list(ar=sigma),n)\n  return(ar.sim)\n}\n\n# Generate X7\nx7.gen<- function(n, q)\n{\n  ar.sim<-arima.sim(model=list(ar=0.5),n=n*q)\n  return(matrix(ar.sim,nrow=n))\n}\n\n# Generate X8\nx8.gen<- function(n,q)\n{\n  return(rmvnorm(n,,diag(q)))\n}\n\n# Generate X9\nx9.gen<- function(n,q)\n{\n  return(rmvnorm(n,,2*diag(q)))\n}\n\n# Generate X10\nx10.gen<- function(n, q, sigma=0.9)\n{\n  ar.sim <- matrix(NA,n,q)\n  for( i in 1:q)\n    ar.sim[,i]<-arima.sim(model=list(ar=sigma),n)\n  return(ar.sim)\n}\n\n# Get upper triangle\nget.upper.tri <- function(x)\n{\n  return(x[upper.tri(x, diag=FALSE)])\n}\n\ndata.gen <- function(p, n, m, q, seed = 1000, rho)\n{\n  set.seed(seed)\n  t <- t.gen(m)\n  X <- array(NA,dim=c(p, n, q))\n  X[1,,] <- x1.gen(n,q)\n  X[2,,] <- x2.gen(n,q)\n  X[3,,] <- x3.gen(n,q)\n  X[4,,] <- x4.gen(n,q)\n  X[5,,] <- x5.gen(n,q)\n  beta1 <- beta1.gen(X[1,,], t)\n  beta2 <- beta2.gen(X[2,,], t)\n  Y.star <- mu.gen(t,n) + beta1 + beta2 + err.gen(n,m,rho)\n  m.i <- dis.uni(n)\n  Y.star2 <- NULL\n  index <- NULL\n  t.star <- NULL\n  for(i in 1:n)\n  {\n\tindex[[i]] <- sort(sample(seq(1:m), m.i[i]), decreasing = FALSE)\n  \tY.star2[[i]] <- Y.star[index[[i]],i]\n\tt.star[[i]] <- t[index[[i]]]\n  }\n#   mu.hat <- sapply(Y.star2, mean)\n#   Y <-lapply(seq_along(Y.star2), function(i)  unlist(Y.star2[i])-mu.hat[i])\n  return(list(X = X, Y = Y.star2, t.star=t.star))\n}\n\nkern.sel <- function(k,s)\n{\n  if (k==1)\n    return(rbfdot(s))\n  else if(k==2)\n    return(laplacedot(s))\n  else if (k==3)\n    return(polydot(2,s))\n  else if (k==4)\n    return(polydot(3,s))\n}\n\nvar.sel <- function(p, n, X, Y, t.star, sigma, choice = 1, b, d)\n{\n  len <- length(sigma)\n  T <- array(NA, dim = c(p,n,n))\n  R <- matrix(NA,n*(n-1)/2, p)\n  Y0 <- unlist(Y)\n  t0 <- unlist(t.star)\n  index<- NULL\n  for( i in 1:n)\n  index <- c(index, rep(i,length(Y[[i]])))\n  data <- cbind(index, Y0, t0)\n  mle <- fpca.mle(data, b, d)\n  scores <- fpca.score(data, mle$grid, mle$fitted_mean, mle$eigenvalues, mle$eigenfunctions, mle$error_var, d)\n  Y1 <- scores%*%t(scores)\n  sum.Y <- get.upper.tri(Y1)\n  coeff <- matrix(0, len, p)\n  se <- matrix(NA, len, p)\n  max <- rep(1e32,p)\n  for( iter in 1: len)\n  {\n  kernel <- kern.sel(choice, sigma[iter])\n  for( i in 1: p)\n    T[i,,] <-  kernelMatrix(kernel,X[i,,])\n\n  for( i in 1: p)\n    R[,i] <- get.upper.tri(T[i,,])\n\n  cv <- cv.nnlasso(R, sum.Y, family=\"normal\", nlambda=100, plot = FALSE, errorbars = FALSE)\n  lambda <- cv$lambda #keeps changing\n  l1 <- cv$lambdas[1]\n  if(lambda==l1)\n   { se[iter,]<- max\n  }else {Tau.nn <- nnlasso(R, sum.Y, path=FALSE, lambda = lambda, family = \"normal\", SE=TRUE, eps=-1e-64)\n  coeff[iter,]<- Tau.nn$coef[2,]\n  se[iter,]<- Tau.nn$se[-1]\n  }\n  }\n  min <- which.min(apply(se^2,1,sum))\n  min.coeff<- coeff[min,]\n  sig <- sigma[min]\n  ls <- lsfit(R, sum.Y, intercept = FALSE)$coef\n  return(list(coeff = min.coeff, sig=sig, ls = ls))\n}\n\n\n## Body of code starts here\n\na <- 2\nb <- 10 # Number of basis functions\nd <- 5 # Number of non-zero eigen values\ns <- 2016\nn <- 100\nrep <- 1000\nm <- 50\np <- 5\nq <- 5\nt <- t.gen(m)\ncoeff.est <- matrix(NA, rep, p)\nper.false <- rep(TRUE, rep)\nls <- matrix(NA, rep, p)\nls.l <- matrix(NA, rep, p)\nX.l <- array(NA, c(p,n,q))\ncoeff.est.l <- matrix(NA, rep, p)\nper.false.l <- rep(TRUE, rep)\n# coeff.est.q <- matrix(NA, rep, p)\n# per.false.q <- rep(TRUE, rep)\n# ls.q <- matrix(NA, rep, p)\n# coeff.est.c <- matrix(NA, rep, p)\n# per.false.c <- rep(TRUE, rep)\n# ls.c <- matrix(NA, rep, p)\nbeta1 <-array(NA, c(rep,m,n))\nbeta2 <-array(NA, c(rep,m,n))\nsigma <- 2^seq(-5,1)\nsig <- rep(NA, rep)\nsig.l <- rep(NA, rep)\nrho <- 0.6\n\nfor( r in 1:rep)\n{\n\n  # Generate data\n  data <- data.gen(p, n, m, q, seed = s, rho=rho)\n  X <- data$X\n  Y <- data$Y\n  t.star <- data$t.star\n\n  # Get coefficients\n  results <- try(var.sel(p, n, X, Y, t.star, sigma, 1, b, d), silent= TRUE)\n  coeff.est[r,] <- try(results$coeff, silent= TRUE)\n  ls[r,] <- try(results$ls, silent= TRUE)\n  sig[r]<- try(results$sig, silent= TRUE)\n\n  results.l <- try(var.sel(p, n, X, Y, t.star, sigma, 2, b, d), silent= TRUE)\n  coeff.est.l[r,] <- try(results.l$coeff, silent= TRUE)\n  ls.l[r,] <- try(results.l$ls, silent= TRUE)\n  sig.l[r] <- try(results.l$sig, silent= TRUE)\n\n#   results.q <- var.sel(p, n, X, Y, dt, sigma, 3)\n#   coeff.est.q[r,] <- results.q$coeff\n#   ls.q[r,] <- results.q$ls\n#\n#   results.c <- var.sel(p, n, X, Y, dt, sigma, 4)\n#   coeff.est.c[r,] <- results.c$coeff\n#   ls.c[r,] <- results.c$ls\n\n  s <- s + 1\n\n}\n\nper0 <- colMeans(coeff.est>1e-4)*100\nper.true <- (coeff.est[,1]>1e-4) & (coeff.est[,2]>1e-4)\n\nfor( i in (a + 1) : p )\n  per.false <- per.false & (coeff.est[,i]<=1e-4)\nper.whole <- per.true & per.false\n\nper.true <- mean(per.true)*100\nper.false <- mean(per.false)*100\nper.whole <- mean(per.whole)*100\n\n#boxplot(ls, outline = FALSE)\n\nper.l0 <- colMeans(coeff.est.l>1e-4)*100\nper.true.l <- (coeff.est.l[,1]>1e-4) & (coeff.est.l[,2]>1e-4)\nfor( i in (a + 1) : p )\n  per.false.l <- per.false.l & (coeff.est.l[,i]<=1e-4)\nper.whole.l <- per.true.l & per.false.l\nper.true.l <- mean(per.true.l)*100\nper.false.l <- mean(per.false.l)*100\nper.whole.l <- mean(per.whole.l)*100\n#boxplot(ls.l, outline = FALSE)\n\n# per.q0 <- colMeans(coeff.est.q>1e-4)*100\n# per.true.q <- (coeff.est.q[,1]>1e-4) & (coeff.est.q[,2]>1e-4)\n# for( i in (a + 1) : p )\n#   per.false.q <- per.false.q & (coeff.est.q[,i]<=1e-4)\n# per.whole.q <- per.true.q & per.false.q\n# per.true.q <- mean(per.true.q)*100\n# per.false.q <- mean(per.false.q)*100\n# per.whole.q <- mean(per.whole.q)*100\n# #boxplot(ls.q, outline = FALSE)\n#\n# per.c0 <- colMeans(coeff.est.c>1e-4)*100\n# per.true.c <- (coeff.est.c[,1]>1e-4) & (coeff.est.c[,2]>1e-4)\n# for( i in (a + 1) : p )\n#   per.false.c <- per.false.c & (coeff.est.c[,i]<=1e-4)\n# per.whole.c <- per.true.c & per.false.c\n# per.true.c <- mean(per.true.c)*100\n# per.false.c <- mean(per.false.c)*100\n# per.whole.c <- mean(per.whole.c)*100\n# #boxplot(ls.c, outline = FALSE)\n#\n# per0\n# per.l0\n# per.q0\n# per.c0\n#\n# per.true\n# per.false\n# per.whole\n#\n# per.true.l\n# per.false.l\n# per.whole.l\n#\n# per.true.q\n# per.false.q\n# per.whole.q\n#\n# per.true.c\n# per.false.c\n# per.whole.c\n\nsig\nsig.l\n\n#refund/fpca.sc,fpca.face\n#Generate error from eigen function\n",
    "created" : 1510123447017.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "157031818",
    "id" : "45E66627",
    "lastKnownWriteTime" : 1510154591,
    "last_content_update" : 1510154591023,
    "path" : "C:/partition1/NCSU/Research/Dr. Maity/varying_m.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}