{
    "collab_server" : "",
    "contents" : "#Missing data\n#Sigma in T\n#time incorporated in kernel\n#Permutation method\n\nrequire(mvtnorm)\nrequire(mgcv)\nrequire(nnlasso)\nrequire(kernlab)\nrequire(clusterGeneration)\nrequire(glmnet)\nrequire(refund)\nrequire(fpca)\nrequire(face)\nrequire(rARPACK)\nsetwd(\"/mnt/home/mbiswas\")\n\n# Getting the intervals\ndis.uni <- function(n)\n{\n  m.i <- ceiling(runif(n,6,14))\n  return(m.i)\n}\n\n# generate t\nt.gen <- function(m)\n{\n  return(seq(0,1,len = m))\n}\n\n# generate mu\nmu.gen <- function(t)\n{\n  return(t)\n}\n\n# Generate error\nerr.gen<- function(n, m, t)\n{\n  zi <- rmvnorm(n,,diag(c(1, 2)))\n  wn <- matrix(rnorm(n*m), n)\n  fn <- sqrt(2) * rbind(cos(2 * pi * t), sin(2 * pi * t))\n  e <- zi %*% fn + wn\n  return(t(e))\n}\n\n# Generate X1\nx1.gen<- function(n,q)\n{\n  return(t(rmvnorm(n,,diag(q))))\n}\n\ndata.gen <- function(n, m, t, q, seed = 1000, prob)\n{\n  set.seed(seed)\n  X <- x1.gen(n,q)\n  Z <- gen.cov(n, prob)\n  m.i <- dis.uni(n)\n  index <- NULL\n  t.star <- NULL\n  for(i in 1:n)\n  {\n    index[[i]] <- sort(sample(seq(1:m), m.i[i]), decreasing = FALSE)\n    t.star[[i]] <- t[index[[i]]]\n  }\n  return(list(X = X, Z = Z, t.star=t.star, index = index, m.i = m.i))\n}\n\nker.X <- function(X, E)\n{\n  require(kernlab)\n  kern <- rbfdot(0.5)\n  seq <- seq(1:ncol(X))\n  # X.star <- outer(seq, seq, function(i, j) as.numeric(kern(X[,i], X[,j])))\n  X1 <- sapply(seq, function(j) sapply(seq, function(i) kern(X[,i], X[,j])))\n  K <- kronecker(X.star, E)\n  return(K)\n}\n\n# ker.X2 <- function(X,t, m,)\n# {\n#   t <- as.matrix(t)\n#   c <- sum(outer(seq(1:m), seq(1:m), function(i,j) exp(-abs(t[i]-t[j]))))\n#   K <- c*t(X)%*%X\n#   return(K)\n# }\n\nkern.miss <- function(index.star, K)\n{\n  K.star <- K[index.star,index.star]\n  return(K.star)\n}\n\nest.sig <- function(Y, m, m.i, t, t.star, seq, m.i.cum.low, m.i.cum, n, index)\n{\n  l <- length(unlist(t.star))\n  dat <- data.frame(subj = c(unlist(sapply(seq, function(x) rep(x, m.i[x])))),\n                    argvals = unlist(t.star),\n                    y = unlist(Y))\n  f <- face.sparse(dat, argvals.new = t)\n  eval <- f$eigenvalues\n  evec <- f$eigenfunctions\n  if(f$var.error.hat[1] != 0)\n  {f2 <- f$var.error.hat[1]}else\n    f2 <- mean((f$Y-f$Yhat)^2, na.rm=TRUE)\n  if(length(eval) == 1)\n  {  sig <- eval * evec %*% t(evec) + f2*diag(m)\n  }else\n    sig <- evec%*%diag(eval)%*%t(evec) + f2*diag(m)\n  #abc <- sig[unlist(index),unlist(index)]\n  #prev line gave matrix with non 0 off diag. Can we fix this?\n  sigi <- solve(sig)\n  ABC <- matrix(0, l, l)\n  for(i in 1:n)\n    ABC[m.i.cum.low[i]:m.i.cum[i], m.i.cum.low[i]:m.i.cum[i]] <- sigi[unlist(index[i]), unlist(index[i])]\n  #as.matrix(bdiag(list(matrix(seq(1:4),2), matrix(seq(1:9),3))))\n  return(list(sig = sig, sigi = ABC, eval = eval, evec = evec, f2 = f2))\n}\n\n\ntest.stat <- function(Y.sigi, K)\n{\n  T <- t(Y.sigi) %*% K %*% Y.sigi\n  return(T)\n}\n\n# distn <- function(X, t, m, n, index, sigma, c)\n# {\n#   # y <- multi(n, m, eval, evec, f2)\n#   y <- mvrnorm(n, rep(0, m), sigma)\n#   K <- ker.X(X, t, c)\n#   Y.0 <- matrix(0,m,n)\n#   for(i in 1:n)\n#     Y.0[index[[i]],i] <- y[i, index[[i]]]\n#   T <- sum(Y.0 %*% K %*% t(Y.0))\n#   return(T)\n#\n# }\n\ngen.cov <- function(n, prob)\n{\n  z0 <- rep(1, n)\n  z1 <- rnorm(n)\n  z2 <- rbinom(n, 1, prob)\n  return(rbind(z0, z1, z2))\n}\n\ngen.eta <- function(t)\n{\n  mu <- mu.gen(t)\n  eta1 <- sin(2*pi*t)\n  eta2 <- cos(2*pi*t)\n  return(rbind(mu, eta1, eta2))\n}\n\ntolist <- function(Y, m.i, n)\n{\n  c <- 1\n  Y.l <- NULL\n  for(i in 1:n)\n  {\n    Y.l[[i]] <- Y[c : (c + m.i[i] - 1)]\n    c <- c + m.i[i]\n  }\n  return(Y.l)\n}\n\nget.half <- function(sigi)\n{\n  svd <- svd(sigi)\n  half <- svd$u %*% diag(sqrt(svd$d)) %*% t(svd$v)\n  return(half)\n}\n\nget.eigen <- function(sig.star, m)\n{\n  eigen <- eigs_sym(sig.star, m)\n  return(eigen)\n}\n\ngen.beta <- function(x,t)\n{\n  return(kronecker(t(exp(-colMeans(x))/2),t))\n}\n\ny.gen <- function(X, Z, t, delta, n, m, index)\n{\n  Y.star <- t(gen.eta(t)) %*% Z + delta * gen.beta(X,t) + err.gen(n, m, t)\n  Y.star2 <- NULL\n  for(i in 1:n)\n    Y.star2[[i]] <- Y.star[index[[i]],i]\n  return(Y.star2)\n}\n\nker <- function(K, index.star2)\n{\n  #same as ker.miss\n  K1 <- K[index.star2, index.star2]\n  return(K1)\n}\n## Body of code starts here\n\ns <- 2017\nn <- 40\nrep <- 10\nm <- 51\nq <- 5\nt <- t.gen(m)\nsim <- 1000\nT1 <- rep(NA, sim)\nprob <- 0.4\nseq <- seq(1:n)\ndel <- 11\np.val <- matrix(NA, del, rep)\npow <- rep(NA, del)\nE <- exp(-outer(t, t, function(a, b){abs(a-b)}))\nseq2 <- seq(0, 10, length = del)\n#seq2 <- 10\n\nfor( r in 1:rep)\n{\n  c <- 1\n  # Generate data\n  data <- data.gen(n, m, t, q, seed = s, prob)\n  index <- data$index\n  X <- data$X\n  Z <- data$Z\n  m.i <- data$m.i\n  m.i.cum <- cumsum(m.i)\n  m.i.cum.low <- c(0, m.i.cum[-n])+1\n  Z1 <- sapply(seq,function(i) rep(Z[2,i], m.i[i]))\n  Z2 <- sapply(seq,function(i) rep(Z[3,i], m.i[i]))\n  Z1 <- c(unlist(Z1))\n  Z2 <- c(unlist(Z2))\n  t.star <- data$t.star\n  T <- c(unlist(t.star))\n  K <- ker.X(X, E)\n  index.star <- unlist(sapply(seq, function(i) unlist(index[i])+m*(i-1)))\n  K.0 <- kern.miss(index.star, K)\n\n  for(delta in seq2)\n  {\n    Y <- y.gen(X, Z, t, delta, n, m, index)\n    Y0 <- c(unlist(Y))\n\n    fit <- gam(Y0~s(T) + s(T, by = Z1) + s(T, by = Z2))\n    Y.center <- fit$residuals\n\n    # Getting test statistics\n    T0 <- as.vector(test.stat(Y.center, K.0))\n\n\n    #Permuting X and getting different T\n    for(i in 1: sim)\n    {\n      sam <- sample(n)\n      m.i.cum.new <- m.i.cum[sam]\n      m.i.cum.low.new <- m.i.cum.low[sam]\n      index.new <- index[sam]\n      index.star2 <- unlist(sapply(seq, function(i) unlist(index.new[i])+m*(i-1)))\n      index.star3 <- unlist(sapply(seq, function(i) seq(m.i.cum.low.new[i], m.i.cum.new[i])))\n\n      #X.new <- X[, sam]\n      K1 <- kern.miss(index.star2, K)\n      Y.sigi.new <- Y.center[index.star3]\n      # Get test statistic\n      T1[i] <- as.vector(test.stat(Y.sigi.new, K1))\n    }\n\n    #p-value\n    p.val[c, r] <- sum(T1>T0)/sim\n    c <- c + 1\n  }\n  # Ready for next simulation\n  s <- s + 1\n\n}\n\nfor(i in 1:del)\n  pow[i] <- mean(p.val[i,]<0.05, na.rm = TRUE)\n\n\nsave(pow, p.val, file = \"pow_gong_nosig_40.Rdata\")\nsetEPS()\npostscript('pow_gong_nosig_40.eps')\nplot(pow, type ='l', xaxt = \"n\", main = \"Power\")\naxis(1, at = 1:del, labels = seq2)\ndev.off()\n",
    "created" : 1510115042169.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1582356613",
    "id" : "EF45A2FC",
    "lastKnownWriteTime" : 1510120081,
    "last_content_update" : 1510120081021,
    "path" : "C:/partition1/NCSU/Research/Dr. Maity/pow_gong_nosig_40.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}